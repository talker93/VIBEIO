<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Default Media Injector &mdash; C++ SDK 2.2.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="prev" title="Default Media Recorder" href="recorder.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> C++ SDK
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../other/getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../other/run_time_deps.html">Run Time Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../other/supported_platforms.html">Supported Platforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coresdk.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media_io.html">Media IO API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../plugins.html">Plugins</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="recorder.html">Default Media Recorder</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Default Media Injector</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#media-source-for-injector">Media Source for Injector</a></li>
<li class="toctree-l3"><a class="reference internal" href="#passthrough-injector">Passthrough Injector</a></li>
<li class="toctree-l3"><a class="reference internal" href="#paced-injector">Paced Injector</a></li>
<li class="toctree-l3"><a class="reference internal" href="#media-injection-status">Media Injection Status</a></li>
<li class="toctree-l3"><a class="reference internal" href="#media-file-source-sample">Media File Source Sample</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">C++ SDK</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../plugins.html">Plugins</a> &raquo;</li>
      <li>Default Media Injector</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/api/sdk/injector.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="default-media-injector">
<span id="default-injector"></span><h1>Default Media Injector<a class="headerlink" href="#default-media-injector" title="Permalink to this headline"></a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Default Media Injector is considered to be in Beta phase on MacOS and Windows systems.</p>
</div>
<p>The Default Media Injector module provides two different types of injectors:</p>
<ul class="simple">
<li><p>A pass-through injector designed for streaming applications</p></li>
<li><p>A pacing injector designed for media file injecting applications</p></li>
</ul>
<p>Both types of injectors provide connections to <a class="reference internal" href="../injection/audio.html#_CPPv4N7dolbyio5comms16rtc_audio_sourceE" title="dolbyio::comms::rtc_audio_source"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">audio</span></code></a> and <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">video</span></code> sinks for the media
frames to be passed on to. Each of the injectors accepts <a class="reference internal" href="../injection/audio.html#_CPPv4N7dolbyio5comms11audio_frameE" title="dolbyio::comms::audio_frame"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">audio</span> <span class="pre">frames</span></code></a> and <a class="reference internal" href="video.html#_CPPv4N7dolbyio5comms11video_frameE" title="dolbyio::comms::video_frame"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">video</span> <span class="pre">frames</span></code></a>.</p>
<p>The main difference between the two injectors is that the paced injector provides a pacing logic, so that it can queue audio and video frames before injecting them into a conference. The passthrough injector accepts the raw audio and video frames and directly relays them to the CoreSDK. Thus, the application is responsible for invoking the frame injection
interface quickly.</p>
<section id="media-source-for-injector">
<h2>Media Source for Injector<a class="headerlink" href="#media-source-for-injector" title="Permalink to this headline"></a></h2>
<p>Neither of the default injectors provide infrastructure for capturing and decoding media. This is the application’s responsibility; once it has decoded media frames, it can pass them to either of the
aforementioned injectors. We have provided a sample library to showcase how to create a Media Injection Source. This sample library, called <strong>media_source_file</strong>, reads media from a mov/mp4 file
and using the Paced Injector injects the audio and video frames into the CoreSDK. This <strong>media_source_file</strong> library is utilized by the provided sample application to inject media files. The
<a class="reference internal" href="../../other/getting_started.html#getting-started-sample"><span class="std std-ref">Sample application</span></a> page describes how to get media injection running with the sample application. A brief overview of the library is provided <a class="reference internal" href="#media-source-file"><span class="std std-ref">below</span></a>.</p>
<p>The audio provided to the injector, contained by the <a class="reference internal" href="../injection/audio.html#_CPPv4N7dolbyio5comms11audio_frameE" title="dolbyio::comms::audio_frame"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">audio</span> <span class="pre">frame</span></code></a>, should have the following specifications:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 47%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Codec</p></th>
<th class="head"><p>Size</p></th>
<th class="head"><p>Format</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>PCM</p></td>
<td><p>10ms of data</p></td>
<td><p>s16_Int</p></td>
</tr>
</tbody>
</table>
<p>The CoreSDK expects these 10ms chunks of PCM audio to be provided every 10ms. The video frames provided to the Injector, contained in <a class="reference internal" href="video.html#_CPPv4N7dolbyio5comms11video_frameE" title="dolbyio::comms::video_frame"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">video</span> <span class="pre">frames</span></code></a>, must be YUV
pixels.</p>
</section>
<section id="passthrough-injector">
<h2>Passthrough Injector<a class="headerlink" href="#passthrough-injector" title="Permalink to this headline"></a></h2>
<p>The Passthrough Injector acts as a proxy to the RTC Audio/Video sources. A Media Injection Source uses the <a class="reference internal" href="#_CPPv4N7dolbyio5comms6plugin20injector_passthrough18inject_audio_frameERRNSt10unique_ptrI11audio_frameEE" title="dolbyio::comms::plugin::injector_passthrough::inject_audio_frame"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">audio</span></code></a>
and the <a class="reference internal" href="#_CPPv4N7dolbyio5comms6plugin20injector_passthrough18inject_video_frameERRNSt10unique_ptrI11video_frameEE" title="dolbyio::comms::plugin::injector_passthrough::inject_video_frame"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">video</span></code></a> methods to pass frames to the Passthrough Injector, which in turn relays these frames to the CoreSDK.</p>
<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin20injector_passthroughE">
<span id="_CPPv3N7dolbyio5comms6plugin20injector_passthroughE"></span><span id="_CPPv2N7dolbyio5comms6plugin20injector_passthroughE"></span><span id="dolbyio::comms::plugin::injector_passthrough"></span><span class="target" id="classdolbyio_1_1comms_1_1plugin_1_1injector__passthrough"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">dolbyio</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">comms</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">plugin</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">injector_passthrough</span></span></span><span class="w"> </span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="k"><span class="pre">public</span></span><span class="w"> </span><span class="n"><span class="pre">dolbyio</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">comms</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">plugin</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">injector</span></span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin20injector_passthroughE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The interface for the Default Passthrough Media Injector. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin20injector_passthrough20injector_passthroughERR25media_injection_status_cb">
<span id="_CPPv3N7dolbyio5comms6plugin20injector_passthrough20injector_passthroughERR25media_injection_status_cb"></span><span id="_CPPv2N7dolbyio5comms6plugin20injector_passthrough20injector_passthroughERR25media_injection_status_cb"></span><span id="dolbyio::comms::plugin::injector_passthrough::injector_passthrough__media_injection_status_cbRR"></span><span class="target" id="classdolbyio_1_1comms_1_1plugin_1_1injector__passthrough_1a4bfc5a7283e4a4c58285843acdd03238"></span><span class="sig-name descname"><span class="n"><span class="pre">injector_passthrough</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">media_injection_status_cb</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">status_cb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin20injector_passthrough20injector_passthroughERR25media_injection_status_cb" title="Permalink to this definition"></a><br /></dt>
<dd><p>Constructor for the passthrough injector. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>status_cb</strong> – Status callback function object, which the application should provide. The injector invokes the function object for any status changes it encounters and provides the <a class="reference internal" href="#structdolbyio_1_1comms_1_1plugin_1_1media__injection__status"><span class="std std-ref">media_injection_status</span></a> object as a parameter. This callback is invoked on either of the injector’s media injection thread, or possibly on the injection sources thread. Either way the application should ensure this callback is thread-safe. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin20injector_passthroughD0Ev">
<span id="_CPPv3N7dolbyio5comms6plugin20injector_passthroughD0Ev"></span><span id="_CPPv2N7dolbyio5comms6plugin20injector_passthroughD0Ev"></span><span id="dolbyio::comms::plugin::injector_passthrough::~injector_passthrough"></span><span class="target" id="classdolbyio_1_1comms_1_1plugin_1_1injector__passthrough_1a154dc7ddf90e38890f481ff40edcafcf"></span><span class="sig-name descname"><span class="n"><span class="pre">~injector_passthrough</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin20injector_passthroughD0Ev" title="Permalink to this definition"></a><br /></dt>
<dd><p>Destructor for passthrough injector. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin20injector_passthrough18inject_audio_frameERRNSt10unique_ptrI11audio_frameEE">
<span id="_CPPv3N7dolbyio5comms6plugin20injector_passthrough18inject_audio_frameERRNSt10unique_ptrI11audio_frameEE"></span><span id="_CPPv2N7dolbyio5comms6plugin20injector_passthrough18inject_audio_frameERRNSt10unique_ptrI11audio_frameEE"></span><span id="dolbyio::comms::plugin::injector_passthrough::inject_audio_frame__std::unique_ptr:audio_frame:RR"></span><span class="target" id="classdolbyio_1_1comms_1_1plugin_1_1injector__passthrough_1a16a790b65bd3d80c6b3663df2ac9b662"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">inject_audio_frame</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">unique_ptr</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="../injection/audio.html#_CPPv4N7dolbyio5comms11audio_frameE" title="dolbyio::comms::audio_frame"><span class="n"><span class="pre">audio_frame</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">frame</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin20injector_passthrough18inject_audio_frameERRNSt10unique_ptrI11audio_frameEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Inject an audio frame into the conference. The audio frame must contain 10ms of PCM data. </p>
<p>This method directly passes the frames to WebRTC. The application is responsible for providing frames in steady 10ms intervals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>frame</strong> – Audio frame containing raw PCM data.</p>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>true</strong> – On successful push of frame. </p></li>
<li><p><strong>false</strong> – On failure to push frame. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin20injector_passthrough18inject_video_frameERRNSt10unique_ptrI11video_frameEE">
<span id="_CPPv3N7dolbyio5comms6plugin20injector_passthrough18inject_video_frameERRNSt10unique_ptrI11video_frameEE"></span><span id="_CPPv2N7dolbyio5comms6plugin20injector_passthrough18inject_video_frameERRNSt10unique_ptrI11video_frameEE"></span><span id="dolbyio::comms::plugin::injector_passthrough::inject_video_frame__std::unique_ptr:video_frame:RR"></span><span class="target" id="classdolbyio_1_1comms_1_1plugin_1_1injector__passthrough_1a709913fa0accb6dcbef3ab45594e4c06"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">inject_video_frame</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">unique_ptr</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="video.html#_CPPv4N7dolbyio5comms11video_frameE" title="dolbyio::comms::video_frame"><span class="n"><span class="pre">video_frame</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">frame</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin20injector_passthrough18inject_video_frameERRNSt10unique_ptrI11video_frameEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Inject a raw video frame into the conference. The video frame must contain YUV pixels. </p>
<p>This method directly passes the frames to WebRTC. The application is responsible for delivering frames at a proper rate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>frame</strong> – The video frame.</p>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>true</strong> – On successful push of frame. </p></li>
<li><p><strong>false</strong> – On failure to push frame. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="paced-injector">
<h2>Paced Injector<a class="headerlink" href="#paced-injector" title="Permalink to this headline"></a></h2>
<p>The Paced Injector ensures that an application provides media frames to the CoreSDK at desired intervals. This is useful for applications that read from media files and produce frames quite quickly. The Paced Injector provides audio to
the CoreSDK in intervals of 10ms and has a configurable option for the video frame interval that specifies how quickly video frames should be provided. The injector
provides frames at these intervals by temporarily storing audio and video in queues. These queues have a limited size; they can store up to 1 second of audio and 300-400ms of video. When the queues are filled, the thread
pushing to the queues is blocked until a free space is available. The Paced Injector also provides methods for managing the pace, such as starting and stopping the pacing threads, clearing the
queues, and setting the video frame interval. If media file injection is paused by the injection source, silence should be injected into the conference to avoid AV sync issues when resuming the injection.
The Paced Injector also provides a method for injecting silent audio frames in 10ms chunks into the conference.</p>
<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin14injector_pacedE">
<span id="_CPPv3N7dolbyio5comms6plugin14injector_pacedE"></span><span id="_CPPv2N7dolbyio5comms6plugin14injector_pacedE"></span><span id="dolbyio::comms::plugin::injector_paced"></span><span class="target" id="classdolbyio_1_1comms_1_1plugin_1_1injector__paced"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">dolbyio</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">comms</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">plugin</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">injector_paced</span></span></span><span class="w"> </span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="k"><span class="pre">public</span></span><span class="w"> </span><span class="n"><span class="pre">dolbyio</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">comms</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">plugin</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">injector</span></span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin14injector_pacedE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The interface for the Default Paced Media Injector. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin14injector_paced14injector_pacedERR25media_injection_status_cb">
<span id="_CPPv3N7dolbyio5comms6plugin14injector_paced14injector_pacedERR25media_injection_status_cb"></span><span id="_CPPv2N7dolbyio5comms6plugin14injector_paced14injector_pacedERR25media_injection_status_cb"></span><span id="dolbyio::comms::plugin::injector_paced::injector_paced__media_injection_status_cbRR"></span><span class="target" id="classdolbyio_1_1comms_1_1plugin_1_1injector__paced_1a31ee76f9f62011e5c0e96515aa747bbf"></span><span class="sig-name descname"><span class="n"><span class="pre">injector_paced</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">media_injection_status_cb</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">status_cb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin14injector_paced14injector_pacedERR25media_injection_status_cb" title="Permalink to this definition"></a><br /></dt>
<dd><p>Constructor for the passthrough injector. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>status_cb</strong> – Status callback function object, which the application should provide. The injector invokes the function object for any status changes it encounters and provide the <a class="reference internal" href="#structdolbyio_1_1comms_1_1plugin_1_1media__injection__status"><span class="std std-ref">media_injection_status</span></a> object as a parameter. This callback is invoked on either of the injector’s media injection thread, or possibly on the injection sources thread. Either way the application should ensure this callback is thread-safe. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin14injector_pacedD0Ev">
<span id="_CPPv3N7dolbyio5comms6plugin14injector_pacedD0Ev"></span><span id="_CPPv2N7dolbyio5comms6plugin14injector_pacedD0Ev"></span><span id="dolbyio::comms::plugin::injector_paced::~injector_paced"></span><span class="target" id="classdolbyio_1_1comms_1_1plugin_1_1injector__paced_1a846722d64f8fa684f0fd1aa19033e27b"></span><span class="sig-name descname"><span class="n"><span class="pre">~injector_paced</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin14injector_pacedD0Ev" title="Permalink to this definition"></a><br /></dt>
<dd><p>Destructor of the paced injector. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin14injector_paced18inject_audio_frameERRNSt10unique_ptrI11audio_frameEE">
<span id="_CPPv3N7dolbyio5comms6plugin14injector_paced18inject_audio_frameERRNSt10unique_ptrI11audio_frameEE"></span><span id="_CPPv2N7dolbyio5comms6plugin14injector_paced18inject_audio_frameERRNSt10unique_ptrI11audio_frameEE"></span><span id="dolbyio::comms::plugin::injector_paced::inject_audio_frame__std::unique_ptr:audio_frame:RR"></span><span class="target" id="classdolbyio_1_1comms_1_1plugin_1_1injector__paced_1a4f1f5ef1706c01e2b61144cc296672fd"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">inject_audio_frame</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">unique_ptr</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="../injection/audio.html#_CPPv4N7dolbyio5comms11audio_frameE" title="dolbyio::comms::audio_frame"><span class="n"><span class="pre">audio_frame</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">frame</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin14injector_paced18inject_audio_frameERRNSt10unique_ptrI11audio_frameEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Inject an audio frame into the conference. The audio frame must contain 10ms of PCM data. </p>
<p>This method can be called more often than every 10ms. The audio frames are queued and provided to WebRTC every 10ms. The queue can hold up to one second of audio; once the queue fills, this function blocks the calling thread until space on the queue is available.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>frame</strong> – Audio frame containing raw PCM data.</p>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>true</strong> – On successful push of frame. </p></li>
<li><p><strong>false</strong> – On failure to push frame. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin14injector_paced18inject_video_frameERRNSt10unique_ptrI11video_frameEE">
<span id="_CPPv3N7dolbyio5comms6plugin14injector_paced18inject_video_frameERRNSt10unique_ptrI11video_frameEE"></span><span id="_CPPv2N7dolbyio5comms6plugin14injector_paced18inject_video_frameERRNSt10unique_ptrI11video_frameEE"></span><span id="dolbyio::comms::plugin::injector_paced::inject_video_frame__std::unique_ptr:video_frame:RR"></span><span class="target" id="classdolbyio_1_1comms_1_1plugin_1_1injector__paced_1ab08a1f56bbdbc96cfa3ae8f71f90607b"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">inject_video_frame</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">unique_ptr</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="video.html#_CPPv4N7dolbyio5comms11video_frameE" title="dolbyio::comms::video_frame"><span class="n"><span class="pre">video_frame</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">frame</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin14injector_paced18inject_video_frameERRNSt10unique_ptrI11video_frameEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Inject a raw video frame into the conference. The video frame must contain YUV pixels. </p>
<p>The desired frame interval for injecting the frames into WebRTC conference should be configured via the <a class="reference internal" href="#classdolbyio_1_1comms_1_1plugin_1_1injector__paced_1a1dce12c7c13d53cfe99cdf915e2914ad"><span class="std std-ref">set_video_frame_interval</span></a> method. The video frames are queued and provided to WebRTC every frame interval. The queue can hold up to 10 video frames; once the queue fills this function blocks the calling thread until space on the queue is available.</p>
<p><dl class="simple">
<dt><strong>Attention</strong></dt><dd><p>This method blocks the calling thread when the video queue is full.</p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>frame</strong> – The video frame.</p>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>true</strong> – On successful push of frame. </p></li>
<li><p><strong>false</strong> – On failure to push frame. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin14injector_paced24set_video_frame_intervalENSt6chrono12millisecondsE">
<span id="_CPPv3N7dolbyio5comms6plugin14injector_paced24set_video_frame_intervalENSt6chrono12millisecondsE"></span><span id="_CPPv2N7dolbyio5comms6plugin14injector_paced24set_video_frame_intervalENSt6chrono12millisecondsE"></span><span id="dolbyio::comms::plugin::injector_paced::set_video_frame_interval__std::chrono::milliseconds"></span><span class="target" id="classdolbyio_1_1comms_1_1plugin_1_1injector__paced_1a1dce12c7c13d53cfe99cdf915e2914ad"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">set_video_frame_interval</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">chrono</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">milliseconds</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">interval</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin14injector_paced24set_video_frame_intervalENSt6chrono12millisecondsE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Sets the video frame interval for injecting video frames into the conference. The pacing injector provides frames to WebRTC at the interval specified by this method, provided the frames are available on the queue. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>interval</strong> – The frame interval in milliseconds. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin14injector_paced21start_video_injectionEv">
<span id="_CPPv3N7dolbyio5comms6plugin14injector_paced21start_video_injectionEv"></span><span id="_CPPv2N7dolbyio5comms6plugin14injector_paced21start_video_injectionEv"></span><span id="dolbyio::comms::plugin::injector_paced::start_video_injection"></span><span class="target" id="classdolbyio_1_1comms_1_1plugin_1_1injector__paced_1aebe0c34e8b3ab4c3ea267895312dbfae"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">start_video_injection</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin14injector_paced21start_video_injectionEv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Enables the video injection pacing thread for taking video frames from the queue and injecting them into the conference. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin14injector_paced20stop_video_injectionEb">
<span id="_CPPv3N7dolbyio5comms6plugin14injector_paced20stop_video_injectionEb"></span><span id="_CPPv2N7dolbyio5comms6plugin14injector_paced20stop_video_injectionEb"></span><span id="dolbyio::comms::plugin::injector_paced::stop_video_injection__b"></span><span class="target" id="classdolbyio_1_1comms_1_1plugin_1_1injector__paced_1adf362565aeff9ea94d230890b3861530"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">stop_video_injection</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">force</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">true</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin14injector_paced20stop_video_injectionEb" title="Permalink to this definition"></a><br /></dt>
<dd><p>Stops the video injection pacing thread from taking video frames from the queue and injecting them into the conference. There are two options for stopping injection; the default option, which is considered forceful stoppage, stops the video pacing thread immediately. Frames that are on the queue when a force stop is invoked remain. The second option, which is considered graceful stoppage allows the caller to wait until all the frames on the queue are popped off by the video pacing thread, then stops the thread. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>force</strong> – Boolean indicating whether to forcefully shutdown the video injection or wait for queue to become empty. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin14injector_paced21start_audio_injectionEv">
<span id="_CPPv3N7dolbyio5comms6plugin14injector_paced21start_audio_injectionEv"></span><span id="_CPPv2N7dolbyio5comms6plugin14injector_paced21start_audio_injectionEv"></span><span id="dolbyio::comms::plugin::injector_paced::start_audio_injection"></span><span class="target" id="classdolbyio_1_1comms_1_1plugin_1_1injector__paced_1aee5ba6c3738752026c32811f981ccf12"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">start_audio_injection</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin14injector_paced21start_audio_injectionEv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Enables the audio injection pacing thread for taking audio frames from the queue and injecting them into the conference. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin14injector_paced29start_audio_silence_injectionEii">
<span id="_CPPv3N7dolbyio5comms6plugin14injector_paced29start_audio_silence_injectionEii"></span><span id="_CPPv2N7dolbyio5comms6plugin14injector_paced29start_audio_silence_injectionEii"></span><span id="dolbyio::comms::plugin::injector_paced::start_audio_silence_injection__i.i"></span><span class="target" id="classdolbyio_1_1comms_1_1plugin_1_1injector__paced_1a836361dd405608b95d6bef9f7f21989c"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">start_audio_silence_injection</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">sample_rate</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">channels</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin14injector_paced29start_audio_silence_injectionEii" title="Permalink to this definition"></a><br /></dt>
<dd><p>Start injecting audio silence into the conference. This should be used if the injection source wants to pause the injection of media while not removing the audio track. In order to keep AV sync on point when the media injection is resumed, calling this function will start the audio injection pacing thread to provide WebRTC with silent audio frames. The silence injection is stopped the same way as regular injection via the stop_audio_injection method. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sample_rate</strong> – The sample rate of the audio stream which was being injected before being paused. </p></li>
<li><p><strong>channels</strong> – The number of channels of the audio stream which was being injected before being paused. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin14injector_paced20stop_audio_injectionEb">
<span id="_CPPv3N7dolbyio5comms6plugin14injector_paced20stop_audio_injectionEb"></span><span id="_CPPv2N7dolbyio5comms6plugin14injector_paced20stop_audio_injectionEb"></span><span id="dolbyio::comms::plugin::injector_paced::stop_audio_injection__b"></span><span class="target" id="classdolbyio_1_1comms_1_1plugin_1_1injector__paced_1aa1025b0a83bc4402e1eae6a7e68eb773"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">stop_audio_injection</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">force</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">true</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin14injector_paced20stop_audio_injectionEb" title="Permalink to this definition"></a><br /></dt>
<dd><p>Stops the audio injection pacing thread from taking audio frames from the queue and injecting them into the conference. There are two options for stopping injection; the default option, which is considered forceful stoppage, stops the audio pacing thread immediately. Frames that are on the queue when a force stop is invoked remain. The second option, which is considered graceful stoppage allows the caller to wait until all the frames on the queue are popped off by the audio pacing thread, then stops the thread. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>force</strong> – Boolean indicating whether to forcefully shutdown the audio injection or wait for queue to be cleared. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin14injector_paced17clear_audio_queueEv">
<span id="_CPPv3N7dolbyio5comms6plugin14injector_paced17clear_audio_queueEv"></span><span id="_CPPv2N7dolbyio5comms6plugin14injector_paced17clear_audio_queueEv"></span><span id="dolbyio::comms::plugin::injector_paced::clear_audio_queue"></span><span class="target" id="classdolbyio_1_1comms_1_1plugin_1_1injector__paced_1aa04ecbef613406d6d55db0b5b83ff611"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_audio_queue</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin14injector_paced17clear_audio_queueEv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Clears the audio queue that is holding audio frames awaiting their injection into conference. This method unblocks any threads that are blocked with the inject_audio_frame method. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin14injector_paced17clear_video_queueEv">
<span id="_CPPv3N7dolbyio5comms6plugin14injector_paced17clear_video_queueEv"></span><span id="_CPPv2N7dolbyio5comms6plugin14injector_paced17clear_video_queueEv"></span><span id="dolbyio::comms::plugin::injector_paced::clear_video_queue"></span><span class="target" id="classdolbyio_1_1comms_1_1plugin_1_1injector__paced_1a2692a048e51f18326cbd7791e7767a86"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">clear_video_queue</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin14injector_paced17clear_video_queueEv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Clears the video queue that is holding video frames awaiting their injection into conference. This method unblocks any threads that are blocked with the inject_video_frame method. </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="media-injection-status">
<h2>Media Injection Status<a class="headerlink" href="#media-injection-status" title="Permalink to this headline"></a></h2>
<p>The Media Injection Status is a structure that depicts the status of the injector. It is passed to the application when the status changes.</p>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin22media_injection_statusE">
<span id="_CPPv3N7dolbyio5comms6plugin22media_injection_statusE"></span><span id="_CPPv2N7dolbyio5comms6plugin22media_injection_statusE"></span><span id="dolbyio::comms::plugin::media_injection_status"></span><span class="target" id="structdolbyio_1_1comms_1_1plugin_1_1media__injection__status"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-prename descclassname"><span class="n"><span class="pre">dolbyio</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">comms</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">plugin</span></span><span class="p"><span class="pre">::</span></span></span><span class="sig-name descname"><span class="n"><span class="pre">media_injection_status</span></span></span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_statusE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The current media injection status is expressed via this structure. This structure can be passed to the application by the injector to describe the current status. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-types">Public Types</p>
<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin22media_injection_status5stateE">
<span id="_CPPv3N7dolbyio5comms6plugin22media_injection_status5stateE"></span><span id="_CPPv2N7dolbyio5comms6plugin22media_injection_status5stateE"></span><span class="target" id="structdolbyio_1_1comms_1_1plugin_1_1media__injection__status_1a85c9d624c410b29bfc396335b6f1cb30"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">state</span></span></span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_status5stateE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Enum describing the state of the media. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin22media_injection_status5state7STOPPEDE">
<span id="_CPPv3N7dolbyio5comms6plugin22media_injection_status5state7STOPPEDE"></span><span id="_CPPv2N7dolbyio5comms6plugin22media_injection_status5state7STOPPEDE"></span><span class="target" id="structdolbyio_1_1comms_1_1plugin_1_1media__injection__status_1a85c9d624c410b29bfc396335b6f1cb30a935f6de890c11deee4867656af34ce7a"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">STOPPED</span></span></span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_status5state7STOPPEDE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin22media_injection_status5state9INJECTINGE">
<span id="_CPPv3N7dolbyio5comms6plugin22media_injection_status5state9INJECTINGE"></span><span id="_CPPv2N7dolbyio5comms6plugin22media_injection_status5state9INJECTINGE"></span><span class="target" id="structdolbyio_1_1comms_1_1plugin_1_1media__injection__status_1a85c9d624c410b29bfc396335b6f1cb30a5167dbf356b827d3f7aa735dbeb8c81f"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">INJECTING</span></span></span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_status5state9INJECTINGE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin22media_injection_status5state5ERRORE">
<span id="_CPPv3N7dolbyio5comms6plugin22media_injection_status5state5ERRORE"></span><span id="_CPPv2N7dolbyio5comms6plugin22media_injection_status5state5ERRORE"></span><span class="target" id="structdolbyio_1_1comms_1_1plugin_1_1media__injection__status_1a85c9d624c410b29bfc396335b6f1cb30a607d4465289c1644d8c46c7c667942a6"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ERROR</span></span></span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_status5state5ERRORE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin22media_injection_status4typeE">
<span id="_CPPv3N7dolbyio5comms6plugin22media_injection_status4typeE"></span><span id="_CPPv2N7dolbyio5comms6plugin22media_injection_status4typeE"></span><span class="target" id="structdolbyio_1_1comms_1_1plugin_1_1media__injection__status_1ad5fa6f4a47ea79215e1967dec0178a12"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">type</span></span></span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_status4typeE" title="Permalink to this definition"></a><br /></dt>
<dd><p>The type of media this status is for. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin22media_injection_status4type5AUDIOE">
<span id="_CPPv3N7dolbyio5comms6plugin22media_injection_status4type5AUDIOE"></span><span id="_CPPv2N7dolbyio5comms6plugin22media_injection_status4type5AUDIOE"></span><span class="target" id="structdolbyio_1_1comms_1_1plugin_1_1media__injection__status_1ad5fa6f4a47ea79215e1967dec0178a12a03dc97f325bd0e3348b1b5d0bc8ebe32"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">AUDIO</span></span></span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_status4type5AUDIOE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin22media_injection_status4type5VIDEOE">
<span id="_CPPv3N7dolbyio5comms6plugin22media_injection_status4type5VIDEOE"></span><span id="_CPPv2N7dolbyio5comms6plugin22media_injection_status4type5VIDEOE"></span><span class="target" id="structdolbyio_1_1comms_1_1plugin_1_1media__injection__status_1ad5fa6f4a47ea79215e1967dec0178a12a39399b4ee80ea1bbc5e1d788089e67b1"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">VIDEO</span></span></span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_status4type5VIDEOE" title="Permalink to this definition"></a><br /></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin22media_injection_status22media_injection_statusE4type">
<span id="_CPPv3N7dolbyio5comms6plugin22media_injection_status22media_injection_statusE4type"></span><span id="_CPPv2N7dolbyio5comms6plugin22media_injection_status22media_injection_statusE4type"></span><span id="dolbyio::comms::plugin::media_injection_status::media_injection_status__type"></span><span class="target" id="structdolbyio_1_1comms_1_1plugin_1_1media__injection__status_1af518cf7a33876079c1c876eac779b9fb"></span><span class="sig-name descname"><span class="n"><span class="pre">media_injection_status</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_status22media_injection_statusE4type" title="dolbyio::comms::plugin::media_injection_status::media_injection_status::type"><span class="n"><span class="pre">type</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">type</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_status22media_injection_statusE4type" title="Permalink to this definition"></a><br /></dt>
<dd><p>Constructor taking only the media type. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>type</strong> – Enum value describing the type of media. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin22media_injection_status22media_injection_statusE4type5stateRKNSt6stringE">
<span id="_CPPv3N7dolbyio5comms6plugin22media_injection_status22media_injection_statusE4type5stateRKNSt6stringE"></span><span id="_CPPv2N7dolbyio5comms6plugin22media_injection_status22media_injection_statusE4type5stateRKNSt6stringE"></span><span id="dolbyio::comms::plugin::media_injection_status::media_injection_status__type.state.ssCR"></span><span class="target" id="structdolbyio_1_1comms_1_1plugin_1_1media__injection__status_1a385c97c96458b107965f46d10d7ccdec"></span><span class="sig-name descname"><span class="n"><span class="pre">media_injection_status</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_status22media_injection_statusE4type5stateRKNSt6stringE" title="dolbyio::comms::plugin::media_injection_status::media_injection_status::type"><span class="n"><span class="pre">type</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">type</span></span>, <a class="reference internal" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_status22media_injection_statusE4type5stateRKNSt6stringE" title="dolbyio::comms::plugin::media_injection_status::media_injection_status::state"><span class="n"><span class="pre">state</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">state</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">string</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">description</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_status22media_injection_statusE4type5stateRKNSt6stringE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Explicit constructor taking the type, state and extra description. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> – Enum value describing the type of media. </p></li>
<li><p><strong>state</strong> – Enum value describing the state. </p></li>
<li><p><strong>description</strong> – Extra description of current media state. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin22media_injection_statusD0Ev">
<span id="_CPPv3N7dolbyio5comms6plugin22media_injection_statusD0Ev"></span><span id="_CPPv2N7dolbyio5comms6plugin22media_injection_statusD0Ev"></span><span id="dolbyio::comms::plugin::media_injection_status::~media_injection_status"></span><span class="target" id="structdolbyio_1_1comms_1_1plugin_1_1media__injection__status_1aa1d01d288a4c88c230b0f342e507dfb1"></span><span class="sig-name descname"><span class="n"><span class="pre">~media_injection_status</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_statusD0Ev" title="Permalink to this definition"></a><br /></dt>
<dd><p>Default destructor. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin22media_injection_status5type_E">
<span id="_CPPv3N7dolbyio5comms6plugin22media_injection_status5type_E"></span><span id="_CPPv2N7dolbyio5comms6plugin22media_injection_status5type_E"></span><span id="dolbyio::comms::plugin::media_injection_status::type___type"></span><span class="target" id="structdolbyio_1_1comms_1_1plugin_1_1media__injection__status_1a8b9365e7095fd84bdf42771c5b298dcf"></span><a class="reference internal" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_status4typeE" title="dolbyio::comms::plugin::media_injection_status::type"><span class="n"><span class="pre">type</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">type_</span></span></span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_status5type_E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Holds the value of the type of media </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin22media_injection_status6state_E">
<span id="_CPPv3N7dolbyio5comms6plugin22media_injection_status6state_E"></span><span id="_CPPv2N7dolbyio5comms6plugin22media_injection_status6state_E"></span><span id="dolbyio::comms::plugin::media_injection_status::state___state"></span><span class="target" id="structdolbyio_1_1comms_1_1plugin_1_1media__injection__status_1ae21ae2e332c4808f229c37ef2ffd6869"></span><a class="reference internal" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_status5stateE" title="dolbyio::comms::plugin::media_injection_status::state"><span class="n"><span class="pre">state</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">state_</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><a class="reference internal" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_status5state7STOPPEDE" title="dolbyio::comms::plugin::media_injection_status::STOPPED"><span class="n"><span class="pre">STOPPED</span></span></a><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_status6state_E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Holds the value of current state for single media </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N7dolbyio5comms6plugin22media_injection_status12description_E">
<span id="_CPPv3N7dolbyio5comms6plugin22media_injection_status12description_E"></span><span id="_CPPv2N7dolbyio5comms6plugin22media_injection_status12description_E"></span><span id="dolbyio::comms::plugin::media_injection_status::description___ss"></span><span class="target" id="structdolbyio_1_1comms_1_1plugin_1_1media__injection__status_1a7dcb28b39c722ad7de5c72c06326631f"></span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">string</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">description_</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="p"><span class="pre">{</span></span><span class="p"><span class="pre">}</span></span><a class="headerlink" href="#_CPPv4N7dolbyio5comms6plugin22media_injection_status12description_E" title="Permalink to this definition"></a><br /></dt>
<dd><p>Holds the value of any extra description of current state for single media </p>
</dd></dl>

</div>
</dd></dl>

</section>
<section id="media-file-source-sample">
<span id="media-source-file"></span><h2>Media File Source Sample<a class="headerlink" href="#media-file-source-sample" title="Permalink to this headline"></a></h2>
<p>The Media Source File sample library is a simple library that makes use of LibAV to read, demux, and decode audio and video frames. The top-level entity of this class is
<strong>dolbyio::comms::sample::file_source</strong> that takes an instance of the Paced Injector and creates a capture thread that parses and decodes media. When a media frame is decoded, this entity pushes the frame to the Paced Injector.</p>
<p>The Media File Source sample library provides the ability to parse the following types of media files:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Container</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>MP4</p></td>
</tr>
<tr class="row-odd"><td><p>MOV</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The Media File Source sample is able to decode the following video and audio codecs:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 33%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Codec</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Sample/Pixel Format</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>AAC</p></td>
<td><p>Audio</p></td>
<td><p>float, planar</p></td>
</tr>
<tr class="row-odd"><td><p>H264</p></td>
<td><p>Video</p></td>
<td><p>YUV</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The library is included along with proper CMake file in the package under <strong>share/dolbyio/comms/sample/media_source/</strong> directory. A sample of the top-level object
of the Media Source File library is in the following files:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>

<span class="cm">/***************************************************************************</span>
<span class="cm"> * This program is licensed by the accompanying &quot;license&quot; file. This file is</span>
<span class="cm"> * distributed &quot;AS IS&quot; AND WITHOUT WARRANTY OF ANY KIND WHATSOEVER, either</span>
<span class="cm"> * express or implied. See the License for the specific language governing</span>
<span class="cm"> * permissions and limitations under the License.</span>
<span class="cm"> *</span>
<span class="cm"> *                Copyright (C) 2022 by Dolby Laboratories.</span>
<span class="cm"> ***************************************************************************/</span><span class="w"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;dolbyio/comms/multimedia_streaming/injector.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;comms/sample/media_source/file/libav_wrapper/avcontext.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;comms/sample/media_source/file/source_context.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;comms/sample/media_source/file/utils/audio_buffer.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;comms/sample/media_source/file/utils/frame_pool.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;comms/sample/media_source/file/utils/media_frame.h&quot;</span><span class="cp"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;condition_variable&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;memory&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mutex&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;thread&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">dolbyio</span><span class="o">::</span><span class="nn">comms</span><span class="o">::</span><span class="nn">sample</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">source_state</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">STOPPED</span><span class="p">,</span><span class="w"> </span><span class="n">RESTARTED</span><span class="p">,</span><span class="w"> </span><span class="n">CONTINUE</span><span class="p">,</span><span class="w"> </span><span class="n">RESUMED</span><span class="p">,</span><span class="w"> </span><span class="n">PAUSED</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">file_source_status</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">capturing_audio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">capturing_video</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">source_state</span><span class="w"> </span><span class="n">current_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source_state</span><span class="o">::</span><span class="n">STOPPED</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">using</span><span class="w"> </span><span class="n">audio_pool_frame_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">frame_from_pool</span><span class="o">&lt;</span><span class="n">audio_buffer</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>
<span class="k">using</span><span class="w"> </span><span class="n">video_pool_frame_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">frame_from_pool</span><span class="o">&lt;</span><span class="n">frame</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">file_source</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">file_source</span><span class="o">&gt;</span><span class="w"> </span><span class="n">create</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">files</span><span class="p">,</span><span class="w"></span>
<span class="w">                                             </span><span class="kt">bool</span><span class="w"> </span><span class="n">loop</span><span class="p">,</span><span class="w"></span>
<span class="w">                                             </span><span class="n">dolbyio</span><span class="o">::</span><span class="n">comms</span><span class="o">::</span><span class="n">plugin</span><span class="o">::</span><span class="n">injector_paced</span><span class="o">&amp;</span><span class="w"> </span><span class="n">injection</span><span class="p">,</span><span class="w"></span>
<span class="w">                                             </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">file_source_status</span><span class="o">&amp;</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">status_cb</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">file_source</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">files</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="kt">bool</span><span class="w"> </span><span class="n">loop</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">comms</span><span class="o">::</span><span class="n">plugin</span><span class="o">::</span><span class="n">injector_paced</span><span class="o">&amp;</span><span class="w"> </span><span class="n">injector</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">file_source_status</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">status_cb</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="o">~</span><span class="n">file_source</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Public Interface</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">set_audio_capture</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">enable</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">set_video_capture</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">enable</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">seek</span><span class="p">(</span><span class="kt">int64_t</span><span class="w"> </span><span class="n">time</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">pause</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">resume</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">loop_current_file</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">enables</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">play_new_file</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">file</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_file_playlist</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">file</span><span class="p">);</span><span class="w"></span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">start_capture</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">stop_capture</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">lock</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">restart_capture</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">init_context</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">initialize_av_context</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">playlist_not_finished</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">wait_thread_stopped</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">lock</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">queue_audio_frame</span><span class="p">(</span><span class="n">audio_pool_frame_ptr</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">queue_video_frame</span><span class="p">(</span><span class="n">video_pool_frame_ptr</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">allocate_audio_frame_pool</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">audio_pool_frame_ptr</span><span class="w"> </span><span class="nf">process_audio</span><span class="p">(</span><span class="n">audio_pool_frame_ptr</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">curr_buff</span><span class="p">,</span><span class="w"> </span><span class="n">frame</span><span class="o">&amp;</span><span class="w"> </span><span class="n">aframe</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Managing the capturing thread</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">start_thread</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">thread_function</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">capture_loop</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">capture_loop_exited</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">dolbyio</span><span class="o">::</span><span class="n">comms</span><span class="o">::</span><span class="n">plugin</span><span class="o">::</span><span class="n">injector_paced</span><span class="o">&amp;</span><span class="w"> </span><span class="n">injector_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">frame_pool</span><span class="o">&lt;</span><span class="n">audio_buffer</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">audio_pool_</span><span class="p">{};</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">frame_pool</span><span class="o">&lt;</span><span class="n">frame</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">video_pool_</span><span class="p">{};</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">libav_context</span><span class="o">&gt;</span><span class="w"> </span><span class="n">libav_context_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">file_state</span><span class="w"> </span><span class="n">file_state_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">input_files_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">curr_file_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">capture_state</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">capture_audio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">capture_video</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">running</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">running_silence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">looping</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="n">capture_state</span><span class="w"> </span><span class="n">capture_state_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">thread_state</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">start_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">exit_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">waiting_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">stopped_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="n">thread_state</span><span class="w"> </span><span class="n">thread_state_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">capture_lock_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">capture_thread_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span><span class="w"> </span><span class="n">wait_to_start_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span><span class="w"> </span><span class="n">wait_to_stop_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">capture_executor_</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">file_source_status</span><span class="o">&amp;</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">source_status_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="p">};</span><span class="w">  </span><span class="c1">// namespace dolbyio::comms::sample</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/***************************************************************************</span>
<span class="cm"> * This program is licensed by the accompanying &quot;license&quot; file. This file is</span>
<span class="cm"> * distributed &quot;AS IS&quot; AND WITHOUT WARRANTY OF ANY KIND WHATSOEVER, either</span>
<span class="cm"> * express or implied. See the License for the specific language governing</span>
<span class="cm"> * permissions and limitations under the License.</span>
<span class="cm"> *</span>
<span class="cm"> *                Copyright (C) 2022 by Dolby Laboratories.</span>
<span class="cm"> ***************************************************************************/</span><span class="w"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;comms/sample/media_source/file/source_capture.h&quot;</span><span class="cp"></span>



<span class="k">namespace</span><span class="w"> </span><span class="nn">dolbyio</span><span class="o">::</span><span class="nn">comms</span><span class="o">::</span><span class="nn">sample</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">file_source</span><span class="o">&gt;</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">files</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                 </span><span class="kt">bool</span><span class="w"> </span><span class="n">loop</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">dolbyio</span><span class="o">::</span><span class="n">comms</span><span class="o">::</span><span class="n">plugin</span><span class="o">::</span><span class="n">injector_paced</span><span class="o">&amp;</span><span class="w"> </span><span class="n">injector</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">file_source_status</span><span class="o">&amp;</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">status_cb</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">file_source</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">files</span><span class="p">),</span><span class="w"> </span><span class="n">loop</span><span class="p">,</span><span class="w"> </span><span class="n">injector</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">status_cb</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">file_source</span><span class="o">::</span><span class="n">file_source</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">files</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="kt">bool</span><span class="w"> </span><span class="n">loop</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="n">dolbyio</span><span class="o">::</span><span class="n">comms</span><span class="o">::</span><span class="n">plugin</span><span class="o">::</span><span class="n">injector_paced</span><span class="o">&amp;</span><span class="w"> </span><span class="n">injector</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">file_source_status</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">status_cb</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">injector_</span><span class="p">(</span><span class="n">injector</span><span class="p">),</span><span class="w"></span>
<span class="w">      </span><span class="n">video_pool_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">frame_pool</span><span class="o">&lt;</span><span class="n">frame</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="mi">20</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="p">[]()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">frame</span><span class="p">());</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">          </span><span class="p">[](</span><span class="n">frame</span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">delete</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"> </span><span class="p">})),</span><span class="w"></span>
<span class="w">      </span><span class="n">input_files_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">files</span><span class="p">)),</span><span class="w"></span>
<span class="w">      </span><span class="n">curr_file_</span><span class="p">(</span><span class="n">input_files_</span><span class="p">.</span><span class="n">begin</span><span class="p">()),</span><span class="w"></span>
<span class="w">      </span><span class="n">capture_thread_</span><span class="p">([</span><span class="k">this</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cp">#if defined(__APPLE__)</span>
<span class="w">        </span><span class="n">pthread_setname_np</span><span class="p">(</span><span class="s">&quot;injection_capture&quot;</span><span class="p">);</span><span class="w"></span>
<span class="cp">#elif defined(__linux__)</span>
<span class="w">        </span><span class="n">pthread_setname_np</span><span class="p">(</span><span class="n">capture_thread_</span><span class="p">.</span><span class="n">native_handle</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;injection_capture&quot;</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">        </span><span class="n">thread_function</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="p">}),</span><span class="w"></span>
<span class="w">      </span><span class="n">capture_executor_</span><span class="p">([</span><span class="k">this</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">capture_loop</span><span class="p">();</span><span class="w"> </span><span class="p">}),</span><span class="w"></span>
<span class="w">      </span><span class="n">source_status_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">status_cb</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">curr_file_</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">input_files_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="n">file_state_</span><span class="p">.</span><span class="n">new_file</span><span class="p">(</span><span class="o">*</span><span class="n">curr_file_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Warning: no media file provided, you must provide one before &quot;</span><span class="w"></span>
<span class="w">                 </span><span class="s">&quot;starting injection!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">capture_state_</span><span class="p">.</span><span class="n">looping</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">loop</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">file_source</span><span class="o">::~</span><span class="n">file_source</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">capture_lock_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">capture_state_</span><span class="p">.</span><span class="n">running</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">capture_state_</span><span class="p">.</span><span class="n">capture_audio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">capture_state_</span><span class="p">.</span><span class="n">capture_video</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">stop_capture</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">capture_state_</span><span class="p">.</span><span class="n">running_silence</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">injector_</span><span class="p">.</span><span class="n">stop_audio_injection</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">injector_</span><span class="p">.</span><span class="n">clear_audio_queue</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">injector_</span><span class="p">.</span><span class="n">clear_video_queue</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">thread_state_</span><span class="p">.</span><span class="n">exit_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">wait_to_start_</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">capture_thread_</span><span class="p">.</span><span class="n">join</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Error: Joining capture_thread threw: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">audio_pool_</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">video_pool_</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">libav_context_</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">set_audio_capture</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">enable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">capture_lock_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">capture_state_</span><span class="p">.</span><span class="n">capture_audio</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">enable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Audio state already set to &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">enable</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;Enable&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;Disable&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">capture_state_</span><span class="p">.</span><span class="n">capture_audio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">enable</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Audio set to &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">enable</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;Stop &quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Capture!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">enable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">injector_</span><span class="p">.</span><span class="n">start_audio_injection</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">start_capture</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">stop_capture</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">set_video_capture</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">enable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">capture_lock_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">capture_state_</span><span class="p">.</span><span class="n">capture_video</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">enable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Video state already set to &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">enable</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;Enable&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;Disable&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">capture_state_</span><span class="p">.</span><span class="n">capture_video</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">enable</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Video set to &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">enable</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;Stop &quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Capture!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">enable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">injector_</span><span class="p">.</span><span class="n">start_video_injection</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">start_capture</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">stop_capture</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">seek</span><span class="p">(</span><span class="kt">int64_t</span><span class="w"> </span><span class="n">time</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">capture_lock_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">capture_state_</span><span class="p">.</span><span class="n">running</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">set_next_seek_time</span><span class="p">(</span><span class="n">time</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Failed to Seek, Capture State &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">capture_state_</span><span class="p">.</span><span class="n">running</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;Not&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; Running!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">file_state_</span><span class="p">.</span><span class="n">seek</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">pause</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">capture_lock_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">capture_state_</span><span class="p">.</span><span class="n">running</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Pause Failed, Capture is Not Running!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">file_state_</span><span class="p">.</span><span class="n">pause</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">wait_thread_stopped</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">capture_state_</span><span class="p">.</span><span class="n">running_silence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">injector_</span><span class="p">.</span><span class="n">start_audio_silence_injection</span><span class="p">(</span><span class="n">file_state_</span><span class="p">.</span><span class="n">audio</span><span class="p">.</span><span class="n">sample_rate_</span><span class="p">,</span><span class="w"> </span><span class="n">file_state_</span><span class="p">.</span><span class="n">audio</span><span class="p">.</span><span class="n">channels_</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">resume</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">capture_lock_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">file_state_</span><span class="p">.</span><span class="n">state</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">file_state</span><span class="o">::</span><span class="n">PAUSE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Resume Failed, Current state is not Paused!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Stop injecting silence into the conference</span>
<span class="w">  </span><span class="n">injector_</span><span class="p">.</span><span class="n">stop_audio_injection</span><span class="p">(</span><span class="nb">true</span><span class="w"> </span><span class="cm">/*force stoppage*/</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">capture_state_</span><span class="p">.</span><span class="n">capture_audio</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">injector_</span><span class="p">.</span><span class="n">start_audio_injection</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">capture_state_</span><span class="p">.</span><span class="n">capture_video</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">injector_</span><span class="p">.</span><span class="n">start_video_injection</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">capture_state_</span><span class="p">.</span><span class="n">running_silence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">capture_state_</span><span class="p">.</span><span class="n">running</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">start_thread</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">play_new_file</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">capture_lock_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input_files_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Is our playlist empty</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">input_files_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">input_files_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">file</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">curr_file_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input_files_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">input_files_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">file</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Check if the new file to play is already part of the playlist</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">input_files_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="n">curr_file_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// If it is not check if adding a new file will invalidate</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">input_files_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">input_files_</span><span class="p">.</span><span class="n">capacity</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">input_files_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">file</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">last_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">prev</span><span class="p">(</span><span class="n">input_files_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">iter_swap</span><span class="p">(</span><span class="n">curr_file_</span><span class="p">,</span><span class="w"> </span><span class="n">last_iter</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">curr_file_</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">input_files_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">file</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">last_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">prev</span><span class="p">(</span><span class="n">input_files_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">curr_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input_files_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">curr_iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">input_files_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">curr_iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">curr_iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">current</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">iter_swap</span><span class="p">(</span><span class="n">curr_iter</span><span class="p">,</span><span class="w"> </span><span class="n">last_iter</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">curr_file_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr_iter</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">file_state_</span><span class="p">.</span><span class="n">new_file</span><span class="p">(</span><span class="o">*</span><span class="n">curr_file_</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">add_file_playlist</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">capture_lock_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input_files_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Check if the playlist is empty</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">input_files_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">input_files_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">file</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">curr_file_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input_files_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">input_files_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">file</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Check if the file is already part of the playlist</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">input_files_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">input_files_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">input_files_</span><span class="p">.</span><span class="n">capacity</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="n">input_files_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">file</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">curr_file_</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">input_files_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">file</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input_files_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">input_files_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">current</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">curr_file_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">start_capture</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">capture_state_</span><span class="p">.</span><span class="n">running</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">file_state_</span><span class="p">.</span><span class="n">state</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">file_state</span><span class="o">::</span><span class="n">STOP</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">file_state</span><span class="o">::</span><span class="n">NEW</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">initialize_av_context</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">file_state</span><span class="o">::</span><span class="n">PAUSE</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">capture_state_</span><span class="p">.</span><span class="n">running</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">start_thread</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">stop_capture</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">lock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">capture_state_</span><span class="p">.</span><span class="n">running</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Capture from media file is already stopped!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">capture_state_</span><span class="p">.</span><span class="n">capture_audio</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">capture_state_</span><span class="p">.</span><span class="n">capture_video</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">capture_state_</span><span class="p">.</span><span class="n">capture_audio</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;Still Capturing Audio! &quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;Not Capturing Audio! &quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">capture_state_</span><span class="p">.</span><span class="n">capture_video</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;Still Capturing Video!&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;Not Capturing Video!&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Stop and wait for the thread to reach conditional in thread_function</span>
<span class="w">  </span><span class="n">file_state_</span><span class="p">.</span><span class="n">stop</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">wait_thread_stopped</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">restart_capture</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">init_context</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">init_context</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">initialize_av_context</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">capture_state_</span><span class="p">.</span><span class="n">running</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">injector_</span><span class="p">.</span><span class="n">start_video_injection</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">injector_</span><span class="p">.</span><span class="n">start_audio_injection</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">playlist_not_finished</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">next</span><span class="p">(</span><span class="n">curr_file_</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">input_files_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">wait_thread_stopped</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">lock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">lock</span><span class="p">.</span><span class="n">owns_lock</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">thread_state_</span><span class="p">.</span><span class="n">waiting_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">wait_to_stop_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">thread_state_</span><span class="p">.</span><span class="n">stopped_</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="n">thread_state_</span><span class="p">.</span><span class="n">waiting_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">initialize_av_context</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">file_state_</span><span class="p">.</span><span class="n">name</span><span class="p">().</span><span class="n">empty</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;There is no media file set to read from!&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">libav_context_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">libav_context</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file_state_</span><span class="p">.</span><span class="n">name</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">create_decoder</span><span class="p">(</span><span class="n">AVMEDIA_TYPE_VIDEO</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">create_decoder</span><span class="p">(</span><span class="n">AVMEDIA_TYPE_AUDIO</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">libav_context_</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Failed for reason: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// If the format of the audio in file is different we need a new audio frame</span>
<span class="w">  </span><span class="c1">// pool.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">file_state_</span><span class="p">.</span><span class="n">audio</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">sample_rate</span><span class="p">(),</span><span class="w"> </span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">()))</span><span class="w"></span>
<span class="w">    </span><span class="n">allocate_audio_frame_pool</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">file_state_</span><span class="p">.</span><span class="n">audio</span><span class="p">.</span><span class="n">settings</span><span class="p">(</span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">sample_rate</span><span class="p">(),</span><span class="w"> </span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">injector_</span><span class="p">.</span><span class="n">set_video_frame_interval</span><span class="p">(</span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">frame_interval</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">queue_audio_frame</span><span class="p">(</span><span class="n">audio_pool_frame_ptr</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">injector_</span><span class="p">.</span><span class="n">inject_audio_frame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">audio_frame_impl</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">value</span><span class="p">)));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">queue_video_frame</span><span class="p">(</span><span class="n">video_pool_frame_ptr</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">injector_</span><span class="p">.</span><span class="n">inject_video_frame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">video_frame_impl</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">value</span><span class="p">)));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">allocate_audio_frame_pool</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">audio_pool_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">frame_pool</span><span class="o">&lt;</span><span class="n">audio_buffer</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="mi">100</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="p">[</span><span class="n">samples</span><span class="p">{</span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">sample_rate</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">100</span><span class="p">},</span><span class="w"> </span><span class="n">channels</span><span class="p">{</span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">()},</span><span class="w"></span>
<span class="w">       </span><span class="n">sample_rate</span><span class="p">{</span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">sample_rate</span><span class="p">()}]()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">audio_buffer</span><span class="o">*</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">audio_buffer</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span><span class="w"> </span><span class="n">sample_rate</span><span class="p">,</span><span class="w"> </span><span class="n">channels</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">default_delete</span><span class="o">&lt;</span><span class="n">audio_buffer</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// right now only f32lpp, handle other input formats for audio</span>
<span class="n">audio_pool_frame_ptr</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">process_audio</span><span class="p">(</span><span class="n">audio_pool_frame_ptr</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">curr_buff</span><span class="p">,</span><span class="w"> </span><span class="n">frame</span><span class="o">&amp;</span><span class="w"> </span><span class="n">aframe</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">curr_buff</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Current audio buffer is null!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">aframe</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;No AVFrame provided!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">curr_buff</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">aframe</span><span class="o">-&gt;</span><span class="n">format</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">AV_SAMPLE_FMT_FLTP</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Currently only support AVFrame format Float Planar!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">curr_buff</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">channel_buffer</span><span class="p">[</span><span class="n">AV_NUM_DATA_POINTERS</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">aframe</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">channel_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">aframe</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">aframe</span><span class="o">-&gt;</span><span class="n">nb_samples</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">curr_buff</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">queue_audio_frame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">curr_buff</span><span class="p">));</span><span class="w"></span>
<span class="w">      </span><span class="n">curr_buff</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">frame_from_pool</span><span class="o">&lt;</span><span class="n">audio_buffer</span><span class="o">&gt;</span><span class="p">(</span><span class="n">audio_pool_</span><span class="o">-&gt;</span><span class="n">get_frame</span><span class="p">(),</span><span class="w"> </span><span class="o">*</span><span class="n">audio_pool_</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                        </span><span class="p">[](</span><span class="n">audio_buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">();</span><span class="w"> </span><span class="p">}));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">aframe</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">channel_buffer</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int16_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">curr_buff</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">push</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">curr_buff</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">queue_audio_frame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">curr_buff</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">curr_buff</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">frame_from_pool</span><span class="o">&lt;</span><span class="n">audio_buffer</span><span class="o">&gt;</span><span class="p">(</span><span class="n">audio_pool_</span><span class="o">-&gt;</span><span class="n">get_frame</span><span class="p">(),</span><span class="w"> </span><span class="o">*</span><span class="n">audio_pool_</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                      </span><span class="p">[](</span><span class="n">audio_buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">();</span><span class="w"> </span><span class="p">}));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">curr_buff</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">thread_function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">thread_state_</span><span class="p">.</span><span class="n">exit_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">capture_lock_</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="c1">// Check if someone is waiting to be sure the thread has returned</span>
<span class="w">      </span><span class="c1">// to the stopped state.</span>
<span class="w">      </span><span class="n">thread_state_</span><span class="p">.</span><span class="n">stopped_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">thread_state_</span><span class="p">.</span><span class="n">waiting_</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">wait_to_stop_</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span><span class="w"></span>

<span class="w">      </span><span class="n">wait_to_start_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">thread_state_</span><span class="p">.</span><span class="n">start_</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">thread_state_</span><span class="p">.</span><span class="n">exit_</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>

<span class="w">      </span><span class="n">thread_state_</span><span class="p">.</span><span class="n">stopped_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">thread_state_</span><span class="p">.</span><span class="n">exit_</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">capture_executor_</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">start_thread</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">thread_state_</span><span class="p">.</span><span class="n">start_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">wait_to_start_</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/* This is called on the capture_thread_ after it exits the loop. We check the</span>
<span class="cm"> * current status of the file and act accordingly.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">capture_loop_exited</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">capture_lock_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">capture_state_</span><span class="p">.</span><span class="n">running</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">restart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// If the capture loop exited on it&#39;s own check if we need to loop single</span>
<span class="w">  </span><span class="c1">// file, play next file in play list or just exit.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">file_state_</span><span class="p">.</span><span class="n">state</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">file_state</span><span class="o">::</span><span class="n">PLAYING</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// If the file left capture loop in play state it means there are still</span>
<span class="w">    </span><span class="c1">// like frames on the queue, make sure to let them all be inejcted before</span>
<span class="w">    </span><span class="c1">// continuing.</span>
<span class="w">    </span><span class="n">injector_</span><span class="p">.</span><span class="n">stop_audio_injection</span><span class="p">(</span><span class="nb">false</span><span class="w"> </span><span class="cm">/*wait all frames to be injected*/</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">injector_</span><span class="p">.</span><span class="n">stop_video_injection</span><span class="p">(</span><span class="nb">false</span><span class="w"> </span><span class="cm">/*wait all frames to be injected*/</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">capture_state_</span><span class="p">.</span><span class="n">looping</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">restart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">restart_capture</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">playlist_not_finished</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Go to the next file and set it to start playing once we enter the</span>
<span class="w">      </span><span class="c1">// capture loop</span>
<span class="w">      </span><span class="o">++</span><span class="n">curr_file_</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">file_state_</span><span class="p">.</span><span class="n">new_file</span><span class="p">(</span><span class="o">*</span><span class="n">curr_file_</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">restart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">restart_capture</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">file_state_</span><span class="p">.</span><span class="n">stop</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">libav_context_</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">capture_state_</span><span class="p">.</span><span class="n">capture_audio</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">capture_state_</span><span class="p">.</span><span class="n">capture_video</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">source_status_</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">source_status_</span><span class="p">(</span><span class="n">file_source_status</span><span class="p">{</span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">source_state</span><span class="o">::</span><span class="n">STOPPED</span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// If file is no longer in the play state stop the injection threads and</span>
<span class="w">    </span><span class="c1">// then act accordingly based on the file state</span>
<span class="w">    </span><span class="n">injector_</span><span class="p">.</span><span class="n">stop_audio_injection</span><span class="p">(</span><span class="nb">true</span><span class="w"> </span><span class="cm">/*force stoppage*/</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">injector_</span><span class="p">.</span><span class="n">stop_video_injection</span><span class="p">(</span><span class="nb">true</span><span class="w"> </span><span class="cm">/*force stoppage*/</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">file_state</span><span class="o">::</span><span class="n">SEEK</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">seek_set_time</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">restart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">restart_capture</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">file_state</span><span class="o">::</span><span class="n">NEW</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">injector_</span><span class="p">.</span><span class="n">clear_audio_queue</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">injector_</span><span class="p">.</span><span class="n">clear_video_queue</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">restart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">restart_capture</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">file_state</span><span class="o">::</span><span class="n">STOP</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">injector_</span><span class="p">.</span><span class="n">clear_audio_queue</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">injector_</span><span class="p">.</span><span class="n">clear_video_queue</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">libav_context_</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">thread_state_</span><span class="p">.</span><span class="n">start_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">restart</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">file_source</span><span class="o">::</span><span class="n">capture_loop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">audio_pool_frame_ptr</span><span class="w"> </span><span class="nf">reference_audio_frame</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">frame_from_pool</span><span class="o">&lt;</span><span class="n">audio_buffer</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">audio_pool_</span><span class="o">-&gt;</span><span class="n">get_frame</span><span class="p">(),</span><span class="w"> </span><span class="o">*</span><span class="n">audio_pool_</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="n">audio_buffer</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">();</span><span class="w"> </span><span class="p">}));</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">audio_read_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">frame</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">file_state_</span><span class="p">.</span><span class="n">playing</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">read_single_packet</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Check if the state of the file has changed externally</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">capture_lock_</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">file_state</span><span class="o">::</span><span class="n">state_change</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">file_state_</span><span class="p">.</span><span class="n">state</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">file_state</span><span class="o">::</span><span class="n">PLAYING</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">file_state</span><span class="o">::</span><span class="n">PAUSE</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">packet_finished</span><span class="p">();</span><span class="w"></span>
<span class="w">          </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">packet_to_decoder</span><span class="p">(</span><span class="n">capture_state_</span><span class="p">.</span><span class="n">capture_video</span><span class="p">,</span><span class="w"> </span><span class="n">capture_state_</span><span class="p">.</span><span class="n">capture_audio</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">is_video</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">auto</span><span class="w"> </span><span class="n">vframe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">video_pool_</span><span class="o">-&gt;</span><span class="n">get_frame</span><span class="p">();</span><span class="w"></span>
<span class="w">          </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">frame_from_decoder</span><span class="o">&lt;</span><span class="n">video</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vframe</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">AVERROR</span><span class="p">(</span><span class="n">EAGAIN</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">AVERROR_EOF</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">video_pool_</span><span class="o">-&gt;</span><span class="n">return_frame</span><span class="p">(</span><span class="n">vframe</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vframe</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">format</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">AV_PIX_FMT_YUV420P</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">video_pool_</span><span class="o">-&gt;</span><span class="n">return_frame</span><span class="p">(</span><span class="n">vframe</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Bad video frame format&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="n">queue_video_frame</span><span class="p">(</span><span class="w"></span>
<span class="w">              </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">frame_from_pool</span><span class="o">&lt;</span><span class="n">frame</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">vframe</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">video_pool_</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="n">frame</span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">unref</span><span class="p">();</span><span class="w"> </span><span class="p">}));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">is_audio</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">frame_from_decoder</span><span class="o">&lt;</span><span class="n">audio</span><span class="o">&gt;</span><span class="p">(</span><span class="n">audio_read_frame</span><span class="p">.</span><span class="n">get</span><span class="p">());</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">AVERROR</span><span class="p">(</span><span class="n">EAGAIN</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">AVERROR_EOF</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="c1">// this will return the current audio frame that contains the packets</span>
<span class="w">          </span><span class="c1">// which are left over from last fillage</span>
<span class="w">          </span><span class="n">reference_audio_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">process_audio</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">reference_audio_frame</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">audio_read_frame</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">audio_read_frame</span><span class="o">-&gt;</span><span class="n">unref</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">libav_context_</span><span class="o">-&gt;</span><span class="n">packet_finished</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// All capture_loop stack variables deleted before checking reason for exit</span>
<span class="w">  </span><span class="n">capture_loop_exited</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="p">};</span><span class="w">  </span><span class="c1">// namespace dolbyio::comms::sample</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="recorder.html" class="btn btn-neutral float-left" title="Default Media Recorder" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Dolby Laboratories.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>